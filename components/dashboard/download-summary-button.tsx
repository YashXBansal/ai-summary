"use client";

import { useCallback } from "react";
import { jsPDF } from "jspdf";
import { marked } from "marked";
import { Download } from "lucide-react";
import { Button } from "@/components/ui/button";

export default function DownloadSummaryButton({
  title,
  summaryText,
  file_name,
  createdAt,
}: {
  title: string;
  summaryText: string;
  file_name: string;
  createdAt: string;
}) {
  const handleDownload = useCallback(async () => {
    const doc = new jsPDF({
      orientation: "portrait",
      unit: "pt",
      format: "a4",
    });

    const margin = 40;
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const maxWidth = pageWidth - 2 * margin;
    const lineHeight = 20;
    let cursorY = margin;

    const addLines = (
      lines: string[],
      options: {
        fontSize?: number;
        bold?: boolean;
        color?: [number, number, number];
      } = {}
    ) => {
      const { fontSize = 12, bold = false, color = [30, 30, 30] } = options;
      doc.setFont("Helvetica", bold ? "bold" : "normal");
      doc.setFontSize(fontSize);
      doc.setTextColor(...color);

      for (const line of lines) {
        const wrapped = doc.splitTextToSize(line, maxWidth);
        for (const wrappedLine of wrapped) {
          if (cursorY + lineHeight > pageHeight - margin) {
            doc.addPage();
            cursorY = margin;
          }
          doc.text(wrappedLine, margin, cursorY);
          cursorY += lineHeight;
        }
      }

      cursorY += lineHeight / 2;
    };

    const safeText = summaryText
      .replace(/[^\x00-\x7F]/g, "")
      .replace(/\r\n/g, "\n")
      .replace(/\r/g, "\n");

    // Header
    addLines([title], { fontSize: 18, bold: true, color: [79, 70, 229] });
    addLines([`Generated on: ${new Date(createdAt).toLocaleDateString()}`], {
      fontSize: 12,
      color: [100, 100, 100],
    });
    addLines([`Original File: ${file_name}`], {
      fontSize: 12,
      color: [100, 100, 100],
    });

    doc.setDrawColor(180);
    doc.line(margin, cursorY, pageWidth - margin, cursorY);
    cursorY += lineHeight;

    // ðŸ”¥ Await the Markdown parsing
    const html = await marked.parse(safeText);
    const temp = document.createElement("div");
    temp.innerHTML = html;

    const parseMarkdownToText = (el: HTMLElement): string[] => {
      const output: string[] = [];

      for (const node of Array.from(el.childNodes)) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent?.trim() || "";
          if (text) output.push(text);
        } else if (node instanceof HTMLElement) {
          const tag = node.tagName.toUpperCase();

          switch (tag) {
            case "H1":
            case "H2":
            case "H3":
              output.push("");
              output.push(node.textContent?.toUpperCase() || "");
              output.push("");
              break;
            case "P":
              output.push(node.textContent || "");
              output.push("");
              break;
            case "UL":
              for (const li of node.querySelectorAll("li")) {
                output.push(`â€¢ ${li.textContent?.trim() || ""}`);
              }
              output.push("");
              break;
            case "OL":
              Array.from(node.querySelectorAll("li")).forEach((li, idx) => {
                output.push(`${idx + 1}. ${li.textContent?.trim() || ""}`);
              });
              output.push("");
              break;
            case "PRE":
            case "CODE":
              const code = node.textContent || "";
              const wrappedCode: string[] = doc.splitTextToSize(
                code,
                maxWidth - 20
              );
              output.push(...wrappedCode.map((line: string) => `  ${line}`));
              output.push("");
              break;
            default:
              output.push(...parseMarkdownToText(node));
              break;
          }
        }
      }

      return output.map((line) => line.trimEnd());
    };

    const markdownLines = parseMarkdownToText(temp);
    addLines(markdownLines, { fontSize: 12, color: [30, 30, 30] });

    // Footer
    if (cursorY + lineHeight > pageHeight - margin) {
      doc.addPage();
      cursorY = margin;
    }

    doc.setFontSize(10);
    doc.setTextColor(160);
    doc.text("Generated by AI-Pdf-Summary", margin, cursorY);

    doc.save(`${title}-summary.pdf`);
  }, [title, summaryText, file_name, createdAt]);

  return (
    <Button
      size="sm"
      onClick={handleDownload}
      className="mt-2 inline-flex items-center gap-1 rounded-md border border-rose-700 bg-rose-200 px-3 py-1.5 text-sm font-medium text-indigo-700 transition hover:bg-rose-400 dark:border-rose-400 dark:bg-rose-950 dark:text-indigo-300 dark:hover:bg-rose-900"
    >
      <Download size={12} />
      Summary
    </Button>
  );
}
